{$i aflags.inc}

Uses
     DOS,
     IOError, INIFile,
     XCmdLine, XCrt,
     UEXE, UString;

const
      VERSION         = '2.88';
      MAX_BUFFER      = 4096;
      MAX_OPENFILES   = 10;
      MAX_OUT:longint = 80;
      MAX_FIRST       = 256;
      MAGIC:byte      = 0;
      EINRUECKEN      = '          ';
      CFGFILE         = 'GETEQEXE.CFG';

      MODUS:byte = 0;
      MODI:array[1..4] of char = '|/-\';
      FILES_OPENED:byte = 0;
      PASCAL_OPENED:boolean = false;
      OUT_FILENAME:string[30] = '_outexe.inc';
      SEPERATOR:string[80] = '--------------------------------------------------------------------------';

      MACRO = true;

      { start macros }
      _m_c   = 1;
      _m_f   = _m_c + 1;
      _m_j   = _m_f + 1;
      _m_m   = _m_j + 1;
      _m__   = _m_m + 1;

      { start methods }
      _AAUTO = _m__ + 1;
      _ACALL = _AAUTO + 1;
      _ACS   = _ACALL + 1;
      _AFAR2 = _ACS + 1;
      _AIP   = _AFAR2 + 1;
      _AMOV  = _AIP + 1;
      _AOVR  = _AMOV + 1;
      _C     = _AOVR + 1;
      _I     = _C + 1;
      _J     = _I + 1;

      { start options }
      _B     = _J + 1;
      _E     = _B + 1;
      _F     = _E + 1;
      _H     = _F + 1;
      _M     = _H + 1;
      _NC    = _M + 1;
      _ND    = _NC + 1;
      _NH    = _ND + 1;
      _NP    = _NH + 1;
      _NS    = _NP + 1;
      _O     = _NS + 1;
      _P     = _O + 1;
      _Q     = _P + 1;
      _S     = _Q + 1;
      _T     = _S + 1;
      _V     = _T + 1;
      _X     = _V + 1;
      _Z     = _X + 1;

      START_MACRO = _m_c;
      END_MACRO = _m__;

      START_METHOD = _AAUTO;
      END_METHOD = _J;

      START_OPTION = _B;
      END_OPTION = _Z;

type
     TSwitch = record
       ID:byte;
       view:string[5];
       switch:string[5];
       cfg:boolean;
       desc:string[42];
     end;

const
      Commands:array[START_MACRO..END_OPTION] of TSwitch = (
        (ID:_m_c;   view:'c'; switch:'c'; cfg:false;
         desc:'evaluate a long call (only EXE)'),
        (ID:_m_f;   view:'f'; switch:'f'; cfg:false;
         desc:'evaluate a far jump'),
        (ID:_m_j;   view:'j'; switch:'j'; cfg:false;
         desc:'evaluate a jump/call'),
        (ID:_m_m;   view:'m'; switch:'m'; cfg:false;
         desc:'evaluate a MOV jump'),
        (ID:_m__;   view:'_'; switch:'_'; cfg:false;
         desc:'seperator for macro commands'),

        (ID:_AAUTO; view:'AAUTO'; switch:'AAUTO'; cfg:false;
         desc:'evaluate and ignore all jumps (not tested)'),
        (ID:_ACALL; view:'ACALL'; switch:'ACALL'; cfg:false;
         desc:'check out a long call first'),
        (ID:_ACS;   view:'ACSn '; switch:'ACS'; cfg:false;
         desc:'add CS to old one (subtract if n < 0)'),
        (ID:_AFAR2; view:'AFAR2'; switch:'AFAR2'; cfg:false;
         desc:'check out a far call (JMP FAR [xxyy])'),
        (ID:_AIP;   view:'AIPn '; switch:'AIP'; cfg:false;
         desc:'add IP to old one (subtract if n < 0)'),
        (ID:_AMOV;  view:'AMOV '; switch:'AMOV'; cfg:false;
         desc:'do a MOV jump (MOV xx yy; JMP xx)'),
        (ID:_AOVR;  view:'AOVR '; switch:'AOVR'; cfg:false;
         desc:'compare EXE overlays'),
        (ID:_C;     view:'Cn   '; switch:'C'; cfg:false;
         desc:'Change CS to n (in paragraphs)'),
        (ID:_I;     view:'In   '; switch:'I'; cfg:false;
         desc:'Change IP to n'),
        (ID:_J;     view:'Jn   '; switch:'J'; cfg:false;
         desc:'check up to n jump levels (/J => /J1)'),

        (ID:_B;     view:'B    '; switch:'B'; cfg:true;
         desc:'create binary output to STDOUT'),
        (ID:_E;     view:'En   '; switch:'E'; cfg:false;
         desc:'go to the end of the file - n Bytes.'),
        (ID:_F;     view:'Fpath'; switch:'F'; cfg:true;
         desc:'give the files with the filemask "path"'),
        (ID:_H;     view:'?, /H'; switch:'H'; cfg:false;
         desc:'this help screen'),
        (ID:_M;     view:'Mn   '; switch:'M'; cfg:false;
         desc:'set the magic number for the Pascal output'),
        (ID:_NC;    view:'NC   '; switch:'NC'; cfg:false;
         desc:'do not use the configuration file'),
        (ID:_ND;    view:'ND   '; switch:'ND'; cfg:true;
         desc:'do not disassemble'),
        (ID:_NH;    view:'NH   '; switch:'NH'; cfg:true;
         desc:'disable output of header'),
        (ID:_NP;    view:'NP   '; switch:'NP'; cfg:true;
         desc:'do not write to Pascal file'),
        (ID:_NS;    view:'NS   '; switch:'NS'; cfg:true;
         desc:'do not write to STDOUT'),
        (ID:_O;     view:'O    '; switch:'O'; cfg:true;
         desc:'overwrite the Pascal file without asking'),
        (ID:_P;     view:'Pfile'; switch:'P'; cfg:true;
         desc:'Set "file" as Pascal file'),
        (ID:_Q;     view:'Qn   '; switch:'Q'; cfg:false;
         desc:'Set the length of the Pascal file'),
        (ID:_S;     view:'Sn   '; switch:'S'; cfg:false;
         desc:'stop comapring after n matches (ì)'),
        (ID:_T;     view:'Tn   '; switch:'T'; cfg:false;
         desc:'start comparing at filepos n (0)'),
        (ID:_V;     view:'V    '; switch:'V'; cfg:true;
         desc:'print only NOT identical bytes'),
        (ID:_X;     view:'X    '; switch:'X'; cfg:true;
         desc:'extended output'),
        (ID:_Z;     view:'Zcmd '; switch:'Z'; cfg:false;
         desc:'execute macro command')
      );

type
     CompareEntry = object
       f:file;
       EXEHeader:TEXE;
       OldAttr:word;
       ActBufPos:word;
       BytesRead:word;
       FName:string[80];
       FSize:longint;
       buf:array[1..MAX_BUFFER] of byte;
       nTotalCompare:longint;

       NE_Offset:word;
       PE_IFH:PE_ImageFileHeader;
       PE_OFH:PE_OptionalFileHeader;

       function ActByte:byte;
     end;

     Str10 = string[10];

     JumpRec = record
       ID:byte;
       Offset:integer;
     end;

const
      BUFLEN = 10;

type
     pSmallBuf = ^tSmallBuf;
     tSmallBuf = array [1..BUFLEN] of byte;

var
    a:array[1..MAX_OPENFILES] of CompareEntry;
    nOpenFiles:byte;
    dummy,
    MinBytesRead,
    nConstCount:word;
    nOutCount,
    nBytesFound:longint;
    fout:text;
    OldExit:pointer;

    bOnlyOneFile,
    bCOM, bPE:boolean;
    bSwitch:array[START_MACRO..END_OPTION] of boolean;

{ switch variables }
    nPEIP,
    nIP,
    nCS,
    nEOF,
    nJump,
    nStart,
    nStop:longint;

    sMacro,
    sFileMask:string;

function IsJump (b:byte):boolean;
assembler;
asm
  mov al, 1
  mov bl, b
  cmp b, $E3  { jcxz }
  je  @done
  cmp b, $E8  { call }
  je  @done
  cmp b, $E9  { jmp }
  je  @done
  cmp b, $EB  { jmps }
  je  @done
  xor al, al
@done:
end;

function CompareEntry.ActByte:byte;
begin
  ActByte := buf[ActBufPos];
end;

procedure FastPrintX (s:string);
begin
  if bSwitch [_X] then
    FastPrint (s);
end;

procedure FP (s:string);
begin
  FastPrint (concat (' þ ', s, #13#10));
end;

procedure FPX (s:string);
begin
  if bSwitch [_X] then
    FP (s);
end;

procedure FinishLine;
begin
  FastPrint (#13#10);
end;

procedure FinishLineX;
begin
  if bSwitch [_X] then
    FastPrint (#13#10);
end;

function DecHex (i:byte; v:longint):string;
var s:string;
begin
  s := concat ('[', i2s (v), ' / ');
  if (a[i].FSize < $00010000) and (v < $00010000) then
    s := concat (s, hexword (v))
  else
    s := concat (s, hexlong (v));
  DecHex := concat (s, 'h]');
end;

procedure Print (i:byte; s:string);
begin
  FPX (concat (a[i].FName, ': ', s));
end;

procedure MacroPrint (bMacro:boolean; i:byte; s:string);
begin
  if bMacro then
    FPX (concat (' - ', s))
  else
    Print (i, s);
end;

function GetAddress (s, o:word):string;
begin
  GetAddress := concat (hexword (s), 'h:', hexword (o), 'h');
end;

procedure Error (msg:string);
begin
  FP (msg);
  FP ('Aborting GetEQExe');
  halt (10);
end;

procedure xblockread (i:byte; var data; len:word; var BytesRead:word);
begin
  blockread (a[i].f, data, len, BytesRead);
  CheckIOError (ioresult, a[i].FName);
end;

procedure xseek (i:byte; nPos:longint);
begin
  seek (a[i].f, nPos);
  CheckIOError (ioresult, a[i].FName);
end;

function Data2Hex (i:byte; nPos:longint):string;
const MAXDATA = 10;
var buf:array[1..MAXDATA] of byte;
    s:string;
    j:byte;
begin
  xseek (i, nPos);
  xblockread (i, buf, MAXDATA, dummy);
  s := concat ('Bytes at position ', DecHex (i, nPos), ':');
  for j:=1 to dummy do
    s := concat (s, ' ', hexbyte (buf[j]));
  Data2Hex := s;
end;

procedure ExtendedError (i:byte; nPos:longint; msg:string);
begin
  FP (msg);
  Error (Data2Hex (i, nPos));
end;

procedure NoteSwitch (n:byte);
begin
  FP (concat ('/', Commands[n].view, '  ', Commands[n].desc));
end;

function Command_JMP (i:byte; nStartPos:longint; nCount:byte; bMacro:boolean):longint;
var j:byte;
    Data:JumpRec;
    Offset:word;
    nSave:longint;
begin
  for j:=1 to nCount do
  begin
    nSave := nStartPos;

    xseek (i, nStartPos);
    xblockread (i, Data, SizeOf (Data), dummy);

    case Data.ID of
      { call, jmp }
      $E8,
      $E9:begin
            if (Data.Offset < 0) and
               (nStartPos + Data.Offset > 0) then  { "+" because "+ -" = "-" }
              inc (nStartPos, 3 + Data.Offset)          { 3 for the JMP }
            else
              inc (nStartPos, 3 + word (Data.Offset))   { 3 for the JMP }
          end;
      { jcxz, jmps }
      $E3,
      $EB:inc (nStartPos, 2 + lo (Data.Offset)); { 2 for the command length }
    else
      ExtendedError (i, nStartPos,
                     concat ('File ', a[i].FName, ' does not have ',
                     i2s (nCount), ' unconditional jumps/calls (only ',
                     i2s (j - 1), ').'));
    end;

    if (nStartPos > a[i].FSize) then
    begin
      FP (concat (a[i].FName, ': jump ', i2s (j), ' (', hexbyte (Data.ID),'h) goes out of file'));
      Error (concat ('Jump to ', DecHex (i, nStartPos), '; Filesize = ', i2s (a[i].FSize)));
    end;

    MacroPrint (bMacro, i,
                concat ('jmp/call (', hexbyte (Data.ID), 'h) from ',
                DecHex (i, nSave), ' to ', DecHex (i, nStartPos)));
  end;

  Command_JMP := nStartPos;
end;

function Command_MOV_JMP (i:byte; nPos:longint; bMacro:boolean):longint;
var XJmp:record
           cmd:byte;
           nJumpPos:word;
         end;
begin
  xseek (i, nPos);
  xblockread (i, XJmp, SizeOf (XJmp), dummy);

  if (XJmp.cmd < $B8) or (XJmp.cmd > $BF) then
    ExtendedError (i, nPos,
                   concat (a[i].FName,
                   ': unsupported "MOV reg, value" command was found ',
                   hexbyte (XJmp.cmd), 'h'));

  if bCOM then
    inc (nPos, XJmp.nJumpPos - $100)
  else
    inc (nPos, XJmp.nJumpPos);

  if nPos > a[i].FSize then
    Error (concat ('MOV jump to ', DecHex (i, nPos), ' goes out of file'));

  MacroPrint (bMacro, i, concat ('MOV jump (', hexbyte (XJmp.cmd), 'h)',
                                 ' to ', DecHex (i, nPos)));

  Command_MOV_JMP := nPos;
end;

function Command_LONGCALL (i:byte; nPos:longint; bMacro:boolean):longint;
type CallRec = record
                 ID:byte;
                 o, s:word;
               end;
var Call:CallRec;
begin
  xseek (i, nPos);
  xblockread (i, Call, SizeOf (Call), dummy);

  if (Call.ID = $9A) then
  begin
    nPos := a[i].EXEHeader.GetHeaderSize + longint (Call.s) shl 4;
    MacroPrint (bMacro, i, concat ('long call (9Ah) to ', DecHex (i, nPos)));

    if nPos > a[i].FSize then
      Error (concat ('Long call to ', DecHex (i, nPos), ' goes out of file'));

    Command_LONGCALL := nPos;
  end
  else
    ExtendedError (i, nPos,
                   concat (a[i].FName,
                   ' does not have a long call at pos ',  DecHex (i, nPos)));
end;

function Command_JMP_FAR (i:byte; nPos:longint; bMacro:boolean):longint;
type CallRecMem = record
                    ID:word;
                    ofs:word;
                  end;
     CallRec = record
                 o, s:word;
               end;
var CallMem:CallRecMem;
    Call:CallRec;
begin
  xseek (i, nPos);
  xblockread (i, CallMem, SizeOf (CallMem), dummy);

  if (CallMem.ID = $2EFF) then
  begin
    if not bCOM then
      Error ('Not yet implemented for EXE file :(');

    if bCOM then
      nPos := CallMem.ofs - $0100;  { you know, COM files, ... }

    Print (i, concat ('jump goes to ', DecHex (i, nPos), 'h'));

    xseek (i, nPos);
    xblockread (i, Call, SizeOf (Call), dummy);

    if bCOM then
      dec (Call.s, $0010);  { only $10 because it will be mutiplied by $10
                              later }

    MacroPrint (bMacro, i, concat ('found target address ',
                           GetAddress (Call.s, Call.o)));

    if bCOM then
      nPos := longint (Call.s) shl 4 + Call.o;

    MacroPrint (bMacro, i, concat ('far jump (2EFFh) to ', DecHex (i, nPos)));

    if nPos > a[i].FSize then
      Error (concat ('Fat jump to ', DecHex (i, nPos), ' goes out of file'));

    Command_JMP_FAR := nPos;
  end
  else
    ExtendedError (i, nPos,
                   concat (a[i].FName, ' does not contain a far call at pos ',
                   DecHex (i, nPos)));
end;

procedure SetPascalFilename (s:string);
var drive, dir, name, ext:string;
    p:byte;
begin
  drive := '';
  p := pos (':', s);
  if (p > 0) then
  begin
    if (p = 2) then
      drive := copy (s, 1, p)
    else
      FP ('The position of the ":" is invalid');
    delete (s, 1, p);
  end;

  dir := '';
  repeat
    p := pos ('\', s);
    if (p > 0) then
    begin
      if (p > 1) then
        dir := concat (dir, copy (s, 1, p))
      else
        FP ('A invalid backslash was found');
      delete (s, 1, p);
    end;
  until (p = 0);

  if length (s) > 0 then
    name := s
  else
    name := OUT_FILENAME;

  OUT_FILENAME := concat (drive, dir, name);
end;

{
----------------------------------------------------------------------------
----------------------START OF THE MAIN PROCEDURES--------------------------
----------------------------------------------------------------------------
}

procedure PrintCopyright;
begin
  FP (SEPERATOR);
  FP (concat ('GetEQExe ', VERSION, ' Copyright (c) 1997 - 98 by PHaX'));
  FP ('phax@writeme.com þ http://unet.univie.ac.at/~a9605263/gettyp');
  FP (SEPERATOR);
end;

procedure EvaluateCommandLine;
type Str5 = string[5];
var TmpStr:string;
    nMagic, TmpLong:longint;

    procedure Check (n1, n2:byte);
    begin
      if bSwitch [n1] and bSwitch [n2] then
        Error (concat ('It''s not possible to use /', Commands [n1].switch,
               ' and /', Commands [n2].switch, ' at the same time'));
    end;

    procedure CheckValue (n:byte);
    begin
      if (bSwitch [n]) and (cmdline.GetString (Commands [n].switch) = '') then
        Error (concat ('Please give a value for option ', Commands [n].switch));
    end;

begin
  if bSwitch [_C] then
    nCS        := cmdline.GetInteger ('c') shl 4
  else
    nCS        := cmdline.GetInteger ('acs') shl 4;

  if bSwitch [_I] then
    nIP        := cmdline.GetInteger ('i')
  else
    nIP        := cmdline.GetInteger ('aip');

{ get commandline values }
  nEOF       := cmdline.GetInteger ('e');
  nJump      := cmdline.GetInteger ('j');
  nMagic     := cmdline.GetInteger ('m');
  nStop      := cmdline.GetInteger ('s');
  nStart     := cmdline.GetInteger ('t');
  nPEIP      := cmdline.GetInteger ('y');

{ get commandline strings }
  sFileMask  := cmdline.GetString ('f');
  sMacro     := cmdline.GetString ('z');

  Check (_ACALL, _AFAR2);
  Check (_ACALL, _AMOV);
  Check (_ACALL, _J);

  Check (_AFAR2, _AMOV);
  Check (_AFAR2, _J);

  Check (_AIP, _I);
  Check (_AIP, _T);

  Check (_ACS, _C);
  Check (_ACS, _T);

  Check (_AOVR, _ACALL);
  Check (_AOVR, _ACS);
  Check (_AOVR, _AFAR2);
  Check (_AOVR, _AIP);
  Check (_AOVR, _AMOV);
  Check (_AOVR, _C);
  Check (_AOVR, _I);
  Check (_AOVR, _J);
  Check (_AOVR, _T);

  Check (_AMOV, _J);

  Check (_B, _V);

  Check (_E, _ACALL);
  Check (_E, _ACS);
  Check (_E, _AFAR2);
  Check (_E, _AIP);
  Check (_E, _AMOV);
  Check (_E, _C);
  Check (_E, _I);
  Check (_E, _J);
  Check (_E, _T);

  Check (_T, _I);
  Check (_T, _J);

  Check (_Z, _ACALL);
  Check (_Z, _AFAR2);
  Check (_Z, _AIP);
  Check (_Z, _AMOV);
  Check (_Z, _AOVR);
  Check (_Z, _J);
  Check (_Z, _T);

  Check (_NS, _NP);

  if (bSwitch [_J]) and (nJump = 0) then
    nJump := 1;

  if (bSwitch [_E]) and (nEOF = 0) then
    nEOF := 0;
  nEOF := abs (nEOF);

  CheckValue (_I);
  CheckValue (_C);
  CheckValue (_M);
  CheckValue (_Q);

  CheckValue (_F);
  CheckValue (_Z);

  if (nCS < 0) then
    Error (concat ('Cannot evaluate a CS value of ', i2s (nCS), '.'));

  if (nIP < 0) then
    Error (concat ('Cannot evaluate an IP value of ', i2s (nIP), '.'));

  if (nJump < 0) then
    Error (concat ('Cannot evaluate ', i2s (nJump), ' jumps.'));

  if (nMagic < 0) or (nMagic > 255) then
    Error (concat ('Invalid magic number ', i2s (nMagic), ' (0 - 255).'));

  if (nStop < 0) then
    Error (concat ('Cannot stop after ', i2s (nStop),' byte(s).'));

  TmpStr := cmdline.GetString ('p');
  if (TmpStr > '') then
    SetPascalFilename (TmpStr)
  else
    bSwitch [_P] := false;

  TmpLong := cmdline.GetInteger ('q');
  if (TmpLong > 0) then
    MAX_OUT := TmpLong
  else
    bSwitch [_Q] := false;

  if TmpLong < 0 then
    Error (concat ('Tell me how to write ', i2s (TmpLong), ' bytes to a Pascal file??'));

  if (nMagic > 0) then
    MAGIC := nMagic;
end;

procedure ReadConfigFile;
var I:TINIFile;
    sValue, Name:string;
    Entry:TINIEntry;
    Found:boolean;
    j:byte;
begin
{ check if INI file exists }
  if (not I.init (CFGFile)) then
    if (not I.Init (concat (GetPath (ParamStr (0)), CFGFile))) then
      exit;

  FastPrintX (' þ Configuration file:');

  while (I.GetNextEntry (Name, Entry)) do
    if ((Name[1] = '/') or (Name[1] = '-')) and (length (Name) > 1) then
    begin
      delete (Name, 1, 1);
      Name := upstring (Name);

      Found := false;
      for j := START_METHOD to END_OPTION do
        if (Name = Commands [j].switch) then
        begin
          { invalid switches: /NC, ... }
          if not Commands [j].cfg then
          begin
            FinishLineX;
            I.PrintError (concat ('The switch /', Commands [j].Switch,
                                  ' is not allowed in the configuration file'));
          end;

          if (j = _P) then
          begin
            sValue := copy (Name, length (Commands [j].switch), length (Name));
            if (sValue = '') then
              I.PrintError ('Please give a value for the pascal file.');
            SetPascalFilename (sValue);
          end;

          FastPrintX (concat (' /', Commands [j].switch));

          bSwitch [j] := true;
          Found := bSwitch [j];
        end;

      if (not Found) then
        I.PrintError (concat ('Unknown switch ', Name));
    end
    else
      I.PrintError ('Entry is no switch (start with "-" or "/")');
  I.done;

  FinishLineX;
end;

procedure ShowOptions;
var i:byte;
begin
  FastPrint (' þ Commandline:');
  for i:=1 to cmdline.OptionStringCount do
    FastPrint (concat (' ', cmdline.OptionString (i)));
  FinishLine;

  FPX (SEPERATOR);

  for i:=START_METHOD to END_OPTION do
    if bSwitch [i] then
      NoteSwitch (i);
  FPX (SEPERATOR);
end;

procedure ScanDisk;
var sr:SearchRec;
begin
  nOpenFiles := 0;

  if pos ('.', sFileMask) = 0 then
    sFileMask := concat (sFileMask, '.*');
  FPX (concat ('Scanning for ', Quoted (sFileMask)));

  findfirst (sFileMask, AnyFile, sr);
  while (DOSError = 0) and (nOpenFiles < MAX_OPENFILES) do
  begin
    if (sr.Attr and VolumeID = 0) and
       (sr.Attr and Directory = 0) and
       (sr.name[1] <> '.') then
    begin
      inc (nOpenFiles);
      a [nOpenFiles].FName := sr.name;
      FPX (concat ('Found file ', sr.name));
    end;
    findnext (sr);
  end;

  FPX (SEPERATOR);
end;

procedure ReadCommandline;
var i:byte;
    sr:searchrec;
begin
  nOpenFiles := cmdline.NonOptionStringCount;
  if nOpenFiles > MAX_OPENFILES then
  begin
    FP (concat ('Taking only ', i2s (MAX_OPENFILES), ' of ', i2s (nOpenFiles), ' files'));
    nOpenFiles := MAX_OPENFILES;
  end;

  for i:=1 to nOpenFiles do
  begin
    a[i].FName := UpString (cmdline.NonOptionString (i));

    if (pos ('.', a[i].FName) = 0) then
    begin
      findfirst (concat (a[i].FName, '.*'), Anyfile, sr);
      if doserror = 0 then
      begin
        while (sr.attr and Directory > 0) or
              (sr.attr and VolumeID > 0) do
          findnext (sr);

        FP (concat ('Replacing ', a[i].FName, ' with ', sr.name));
        a[i].FName := sr.name;
      end
      else
        Error (concat ('Cannot find any file matching "', a[i].FName, '.*"'));
    end;
  end;
end;

procedure Syntax;
var done:boolean;
    c:char;
    handle:word absolute output;
    _dx:word;

    procedure Help_Macro;
    var i:byte;
    begin
      FP (SEPERATOR);
      FP ('Macros may have the form [number][cmd [cmd [...]]][number]...');
      FP ('A number always specifies the amount of bytes to skip, a cmd is always');
      FP (' an action like jump or so');
      FP ('');
      FP ('Available macro commands (case sensitive):');
      for i:= START_MACRO to END_MACRO do
        NoteSwitch (i);
      FP (SEPERATOR);
    end;

    procedure Help_Method;
    var i:byte;
    begin
      FP (SEPERATOR);
      FP ('Available methods:');
      for i:= START_METHOD to END_METHOD do
        NoteSwitch (i);
      FP (SEPERATOR);
    end;

    procedure Help_Option;
    var i:byte;
    begin
      FP (SEPERATOR);
      FP ('Available options:');
      for i:= START_OPTION to END_OPTION do
        NoteSwitch (i);
      FP (SEPERATOR);
    end;

begin
  asm
    mov ax, $4400
    mov bx, word ptr handle
    int 21h
    mov _dx, dx
  end;
  if (_dx and $82 <> $82) then
  begin
    FP ('The help system cannot work if the output is redirected ...');
    halt (2);
  end;

  done := false;

  repeat
    FP ('(1) options ³ (2) methods ³ (3) macros ³ (4) all together ³ (rest) exit');
    FastPrint (' þ Your selection: ( )'#8#8);
    c := readkey;
    FastPrint (c);
    FinishLine;

    case c of
      '1':Help_Option;
      '2':Help_Method;
      '3':Help_Macro;
      '4':begin
            Help_Option;
            Help_Method;
            Help_Macro;
          end;
    else
      done := true;
    end;

    FP ('');
  until done;

  halt (1);
end;

procedure AssignHandles;
var i:byte;
begin
  for i:=1 to nOpenFiles do
  begin
    assign (a[i].f, a[i].FName);
    GetFAttr (a[i].f, a[i].OldAttr);
    SetFAttr (a[i].f, Archive);
    reset (a[i].f, 1);
    CheckIOError (ioresult, a[i].FName);

    inc (FILES_OPENED);
    a[i].FSize := FileSize (a[i].f);
  end;
end;

procedure CheckEXEHeader;
var i:byte;
    ID:array[1..2] of word;

    procedure CheckPE;
    begin
      if bPE then
        Error (concat (a[i].FName, ' is no portable executable'));
    end;

label DOSEXE;
begin
  bCOM := true;

  for i:=1 to nOpenFiles do
  begin
    xblockread (i, a[i].EXEHeader, EXE_HEADER_SIZE, dummy);

    if a[i].EXEHeader.IsEXE then
    begin
      if (bCOM) and (i > 1) then
        Error (concat (a[i].FName, ' is an EXE file; previous file was a COM file.'));
      bCOM := false;
    end
    else
    begin
      if (not bCOM) and (i > 1) then
        Error (concat (a[i].FName, ' is a COM file; previous file was an EXE file.'));
    end;

    if (not bCOM) and (a[i].EXEHeader.NEOffsetIsValid) then
    begin
      xseek (i, $3C);
      xblockread (i, a[i].NE_Offset, 2, dummy);

      if (a[i].NE_Offset < a[i].exeheader.GetHeaderSize) then
        goto DOSEXE;

      xseek (i, a[i].NE_Offset);
      xblockread (i, a[i].PE_IFH, SIZEOF_PE_IMAGE_FILE_HEADER, dummy);
      xblockread (i, a[i].PE_OFH, SIZEOF_PE_OPTIONAL_FILE_HEADER, dummy);

      move (a[i].PE_IFH.ID, ID, 4);
      if (ID[1] <> $4550) or (ID[2] <> $0000) then
      begin
        if (ID[1] = $454E) or (ID[1] = $454C) then
          Error (concat (a[i].FName, ' is a new executable'))
        else
          if (ID[1] = $584C) then
            Error (concat (a[i].FName, ' is a linear executable'))
          else
            goto DOSEXE;
      end
      else
      begin
        if (not bPE) and (i > 1) then
          Error (concat (a[i].FName, ' is a new executable.'));
        bPE := true;
        Print (i, 'is a PE portable executable');
      end;
    end
    else
    begin
DOSEXE:
      CheckPE;
      a[i].NE_Offset := 0;
      if (not bCOM) then
        Print (i, 'is a DOS executable')
      else
        Print (i, 'handled as a normal file');
    end;
  end;

  FPX (SEPERATOR);
end;

procedure SearchStartPos;
label FoundPos;
var i:byte;
    nPos:longint;

    function EvaluateMacro (i:byte; nStartPos:longint):longint;
    var len, p:byte;

        function GetNumber:Str10;
        var j:byte;
        begin
          j := p - 1;
          while IsNumberChar (sMacro [j + 1]) do
            inc (j);
          GetNumber := copy (sMacro, p, j - p + 1);
        end;

    var s:Str10;
        nSkip:longint;
    begin
      p := 1;
      len := length (sMacro);

      Print (i, concat ('evaluating macro commands ', Quoted (sMacro),
                        ' at ',  DecHex (i, nStartPos), ':'));

      while (p <= len) do
      begin
        case sMacro[p] of
          '0'..'9':
              begin
                s := GetNumber;
                inc (p, length (s) - 1);

                nSkip := s2i (s);
                inc (nStartPos, nSkip);
                FPX (concat (' - Skipping ', i2s (nSkip), ' byte(s) - now at ', DecHex (i, nStartPos)));
              end;
          'c':begin
                if bCOM then
                  Error ('Long call macro ("c") is not available for COM files.');
                nStartPos := Command_LONGCALL (i, nStartPos, MACRO);
              end;
          'f':nStartPos := Command_JMP_FAR (i, nStartPos, MACRO);
          'j':nStartPos := Command_JMP (i, nStartPos, 1, MACRO);
          'm':nStartPos := Command_MOV_JMP (i, nStartPos, MACRO);
          '_':;  { just do nothing }
        else
          Error (concat ('Cannot evaluate this macro. ',
                         'Error at pos ', i2s (p), ' ', Quoted (sMacro[p]), '.'));
        end;
        inc (p);
      end;
      EvaluateMacro := nStartPos;
    end;

    procedure GetPEEntryPoint (i:byte; var nRes:longint);
    var aOTH:PEObjectTableHandler;
        pObj:pPE_Object;
    begin
      aOTH.init (a[i].PE_IFH.NumberOfSections);
      xseek (i, a[i].NE_Offset +
                SIZEOF_PE_IMAGE_FILE_HEADER +
                a[i].PE_IFH.OptionalHeaderSize);
      xblockread (i, aOTH.pBase^, aOTH.nTableSize, dummy);
      aOTH.GetPhysOfsByRVA (a[i].PE_OFH.AddressOfEntryPoint, nRes);
      aOTH.done;
    end;

begin
  for i:=1 to nOpenFiles do
  begin
{ check for executable overlay }
    if bSwitch [_T] then
    begin
      nPos := nStart;
      if (nPos > a[i].FSize) then
        Error (concat ('The start position exceeds the filesize of ', a[i].FName));
      goto FoundPos;
    end;

{ check for going to the EOF }
    if bSwitch [_E] then
    begin
      nPos := a[i].FSize - nEOF;
      Print (i, concat ('going to EOF - ', i2s (nEOF), ' Bytes ', DecHex (i, nPos)));
      goto FoundPos;
    end;

{ check for executable overlay }
    if bSwitch [_AOVR] then
    begin
      nPos := a[i].EXEHeader.GetSizeInHeader;  { goto overlay start pos }

      if nPos = a[i].FSize then
        Error (concat (a[i].FName, ' has no overlay'));

      goto FoundPos;
    end;

{ set nPos to the starting position }
    if (not bCOM) and (not bPE) then
    begin
      nPos := a[i].EXEHeader.GetAbsoluteIP;  { goto CS:IP }
      Print (i, concat ('original CS:IP = ',
                GetAddress (a[i].EXEHeader.GetCS, a[i].EXEHeader.GetIP),
                ' ð ', DecHex (i, nPos)));
    end
    else
      nPos := 0;

{ PE handling }
    if bPE then
    begin
      GetPEEntryPoint (i, nPos);

      Print (i, concat ('PE entrypoint = ', DecHex (i, nPos)));

      if (nPos > a[i].FSize) then
        Error ('PE entrypoint is out of file.');

      if bSwitch [_C] then
      begin
        FPX (concat ('Disabling switch ', Commands[_C].switch, ' because of PE EXE'));
        bSwitch [_C] := false;
      end;
    end;

{ check for changed CS or IP }
    if bSwitch [_C] or bSwitch [_I] then
    begin
      if not bCOM then
      begin
{ if EXE file compare }
        nPos := a[i].EXEHeader.GetHeaderSize;
        Print (i, concat ('starting at pos ', DecHex (i, nPos)));

{ check if CS is changed }
        if (bSwitch [_C]) then
        begin
          if (bSwitch [_ACS]) then
            inc (nPos, a[i].EXEHeader.GetCS);
          inc (nPos, nCS);
          Print (i, concat ('setting CS to ', i2s (nCS), ' - now at ', DecHex (i, nPos)));
        end
        else
          inc (nPos, a[i].EXEHeader.GetCS);

{ check if IP is changed }
        if (bSwitch [_I]) then
        begin
          if (bSwitch [_AIP]) then
            inc (nPos, a[i].EXEHeader.GetIP);
          inc (nPos, nIP);
          Print (i, concat ('setting IP to ', i2s (nIP), ' - now at ', DecHex (i, nPos)));
        end
        else
          inc (nPos, a[i].EXEHeader.GetIP);
      end
      else  { if COM file - compare; can only be /J; /C is "disabled" in cmdline handling }
      begin
        nPos := nIP;
        Print (i, concat ('Start IP = ', DecHex (i, nPos)));
      end;
    end;  { end CS, IP modify }

         if bSwitch [_Z]     then nPos := EvaluateMacro (i, nPos)
    else if bSwitch [_ACALL] then nPos := Command_LONGCALL (i, nPos, not MACRO)
    else if bSwitch [_AFAR2] then nPos := Command_JMP_FAR (i, nPos, not MACRO)
    else if bSwitch [_AMOV]  then nPos := Command_MOV_JMP (i, nPos, not MACRO)
    else if bSwitch [_J]     then nPos := Command_JMP (i, nPos, nJump, not MACRO);

FoundPos:
    Print (i, concat ('start comparing at ', DecHex (i, nPos)));

    xseek (i, nPos);
    a[i].nTotalCompare := FileSIze (a[i].f) - FilePos (a[i].f);

    FPX (SEPERATOR);
  end;
end;

procedure OpenPascalFile;
begin
{ create pascal include file }
  assign (fout, OUT_FILENAME);
  reset (fout);
  if (ioresult = 0) and (not bSwitch [_O]) then
    Error (concat ('The output file ', OUT_FILENAME, ' already exists.'));
  rewrite (fout);
  CheckIOError (ioresult, OUT_FILENAME);
  write (fout, EINRUECKEN);

  PASCAL_OPENED := true;
end;

procedure InitGraphics;

    function LongMin (a,b:longint):longint;
    begin
      if a < b then
        LongMin := a
      else
        LongMin := b;
    end;

    procedure GetMinTotalCompare (var n:longint);
    var i:byte;
    begin
      n := a[1].nTotalCompare;
      for i:=2 to nOpenFiles do
        n := LongMin (a[i].nTotalCompare, n);

      if bSwitch [_S] then
        n := LongMin (n, nStop);
    end;

var nTotal:longint;
begin
  GetMinTotalCompare (nTotal);
  FPX (concat ('Comparing ', i2s (nTotal), ' bytes total'));
end;

procedure Disassemble (b:byte);
type TREG = array[1..2] of char;
const wREGS:array[0..7] of TREG =
            ('ax', 'cx', 'dx', 'bx', 'sp', 'bp', 'si', 'di');
      bREGS:array[0..7] of TREG =
            ('al', 'cl', 'dl', 'bl', 'ah', 'ch', 'dh', 'bh');
      sJUMP:array[0..15] of TREG =
            ('o ', 'no',
             'b ', 'ae',
             'e ', 'ne',
             'be', 'a ',
             's ', 'ns',
             'p ', 'np',
             'l ', 'ge',
             'le', 'g ');
var s:string;
begin
  s := '';
  case b of
    $00..$05: s := 'add  ..';
    $06: s := 'push es';
    $07: s := 'pop  es';
    $08..$0D: s := 'or   ..';
    $0E: s := 'push cs';
    $0F: s := 'pop  cs';

    $10..$15: s := 'adc  ..';
    $16: s := 'push ss';
    $17: s := 'pop  ss';
    $18..$1D: s := 'sbb  ..';
    $1E: s := 'push ds';
    $1F: s := 'pop  ds';

    $20..$25: s := 'and  ..';
    $26: s := 'es:';
    $27: s := 'daa';
    $28..$2D: s := 'sub  ..';
    $2E: s := 'cs:';
    $2F: s := 'das';

    $30..$35: s := 'xor  ..';
    $36: s := 'ss:';
    $37: s := 'daa';
    $38..$3D: s := 'cmp  ..';
    $3E: s := 'ds:';
    $3F: s := 'das';

    $40..$47: s := concat ('inc  ', wREGS [b - $40]);
    $48..$4F: s := concat ('dec  ', wREGS [b - $48]);

    $50..$57: s := concat ('push ', wREGS [b - $50]);
    $58..$5F: s := concat ('pop  ', wREGS [b - $58]);

    $60: s := 'pusha';
    $61: s := 'popa';
    $62: s := 'bound ..';
    $63: s := 'arpl ..';
    $64: s := 'fs:';
    $65: s := 'gs:';
    $66: s := 'db  66h';
    $67: s := 'db  67h';
    $68: s := 'push ..';
    $69: s := 'imul ..';
    $6A: s := 'push ..';
    $6B: s := 'imul ..';
    $6C: s := 'insb';
    $6D: s := 'insw';
    $6E: s := 'outsb';
    $6F: s := 'outsw';

    $70..$7F: s := concat ('j', sJUMP [b - $70], ' ..');

    $80..$83: s := 'add / or / adc / sbb / and / sub / xor / cmp ..';
    $84: s := 'test ..';
    $85: s := 'test ..';
    $86: s := 'xchg ..';
    $87: s := 'xchg ..';
    $88..$8C: s := 'mov  ..';
    $8D: s := 'lea  ..';
    $8E: s := 'mov  ..';
    $8F: s := 'pop  ..';

    $90: s := 'nop';
    $91..$97: s := concat ('xchg ', wREGS [b - $90], ', ax');
    $98: s := 'cbw';
    $99: s := 'cwd';
    $9A: s := 'call ..';
    $9B: s := 'fwait';
    $9C: s := 'pushf';
    $9D: s := 'popf';
    $9E: s := 'sahf';
    $9F: s := 'lahf';

    $A0..$A3: s := 'mov  ..';
    $A4: s := 'movsb';
    $A5: s := 'movsw';
    $A6: s := 'cmpsb';
    $A7: s := 'cmpsw';
    $A8: s := 'test ..';
    $A9: s := 'test ..';
    $AA: s := 'stosb';
    $AB: s := 'stosw';
    $AC: s := 'lodsb';
    $AD: s := 'lodsw';
    $AE: s := 'scasb';
    $AF: s := 'scasw';

    $B0..$B7: s := concat ('mov  ', bREGS [b - $B0], ', ..');
    $B8..$BF: s := concat ('mov  ', wREGS [b - $B8], ', ..');

    $C0..$C1: s := 'rol / ror / rcl / rcr / shl / shr / ? / sar ..';
    $C2: s := 'retn ..';
    $C3: s := 'retn';
    $C4: s := 'les  ..';
    $C5: s := 'lds  ..';
    $C6..$C7: s := 'mov  ..';
    $C8: s := 'enter ..';
    $C9: s := 'leave';
    $CA: s := 'retf ..';
    $CB: s := 'retf';
    $CC: s := 'int  3';
    $CD: s := 'int  ..';
    $CE: s := 'into';
    $CF: s := 'iret';

    $D0..$D3: s := 'rol / ror / rcl / rcr / shl / shr / ? / sar ..';
    $D4: s := 'aam  ..';
    $D5: s := 'aad  ..';
    $D6: s := 'setalc';
    $D7: s := 'xlat';
    $D8..$DF: s := '; coprocessor method';

    $E0: s := 'loopne ..';
    $E1: s := 'loope ..';
    $E2: s := 'loop ..';
    $E3: s := 'jcxz ..';
    $E4: s := 'in   al, ..';
    $E5: s := 'in   ax, ..';
    $E6: s := 'out  .., al';
    $E7: s := 'out  .., ax';
    $E8: s := 'call ..';
    $E9: s := 'jmp  ..';
    $EA: s := 'jmp  ..';
    $EB: s := 'jmps ..';
    $EC: s := 'in   al, dx';
    $ED: s := 'in   ax, dx';
    $EE: s := 'out  dx, al';
    $EF: s := 'out  dx, ax';

    $F0: s := 'lock';
    $F1: s := '?';
    $F2: s := 'repne';
    $F3: s := 'repe';
    $F4: s := 'hlt';
    $F5: s := 'cmc';
    $F6..$F7: s := 'test / ? / not / neg / mul / imul/ div / idiv ..';
    $F8: s := 'clc';
    $F9: s := 'stc';
    $FA: s := 'cli';
    $FB: s := 'sti';
    $FC: s := 'cld';
    $FD: s := 'std';
    $FE..$FF: s := 'inc / dec / push ..';
  else
    Error (concat ('Unknown opcode ', hexbyte (b), 'h'));
  end;
  if s > '' then
    FastPrint (concat ('   ³ ', s));
end;

procedure CompareFiles;
label StopCompare;
var nPos, nOffset:longint;
    nActByte:byte;

    function WordMin (a,b:word):word;
    assembler;
    asm
      mov ax, a
      mov bx, b
      cmp ax, bx
      jl @okay
      xchg ax, bx
    @okay:
    end;

    procedure GetMinBytesRead (var n:word);
    var i:word;
    begin
      n := a[1].BytesRead;
      for i:=2 to nOpenFiles do
        n := WordMin (a[i].BytesRead, n);
    end;

    procedure ReadAllBufs;
    var i:byte;
        nPos:longint;
    begin
      { read buffer }
      for i:=1 to nOpenFiles do
      begin
        nPos := FilePos (a[i].f);

        xblockread (i, a[i].buf, MAX_BUFFER, a[i].BytesRead);

        Print (i, concat ('read ', i2s (a[i].BytesRead), ' byte(s) at ', DecHex (i, nPos)));

        a[i].ActBufPos := 0;
      end;

      GetMinBytesRead (MinBytesRead);

      FPX (concat ('Now comparing ', i2s (MinBytesRead), ' byte(s)'));
      FPX (SEPERATOR);
    end;

    function AllBufOkay:boolean;
    var i:byte;
    begin
      AllBufOkay := false;
      for i := 1 to nOpenFiles do
        if (a[i].ActBufPos >= MinBytesRead) then
          exit;
      AllBufOkay := true;
    end;

    procedure IncBufPos;
    var i:byte;
    begin
      { increase file pointer }
      for i:=1 to nOpenFiles do
        inc (a[i].ActBufPos);

      inc (nConstCount);
    end;

    function ActBytesAreEqual (nOffset:longint):boolean;
    var i:byte;
        nTarget:longint;
        Data:JumpRec;

    label Again, Next;
    begin
      ActBytesAreEqual := true;

    { autojump evaluation }
      if bSwitch [_AAUTO] then
        for i := 1 to nOpenFiles do
        begin
    Again:
          if IsJump (a[i].ActByte) then
          begin
            move (a[i].buf[a[i].ActBufPos], Data, SizeOf (Data));
            case a[i].ActByte of
              { call, jmp }
              $E8,
              $E9:begin
                    if (a[i].ActBufPos + 3 + word (Data.Offset) > MAX_BUFFER) then
                      goto Next;
                    if (Data.Offset >= $8000) and (nOffset + 3 + Data.Offset > a[i].FSize) then
                      inc (a[i].ActBufPos, 3 + integer (Data.Offset))      { 3 for the command length }
                    else
                      inc (a[i].ActBufPos, 3 + word (Data.Offset));      { 3 for the command length }
                  end;
              { jcxz, jmps }
              $E3,
              $EB:inc (a[i].ActBufPos, 2 + lo (Data.Offset)); { 2 for the command length }
            end;
            goto Again;
          end;
    Next:
        end;

    { normal comparison }
      for i := 1 to nOpenFiles - 1 do
      begin
        if (a[i].ActByte <> a[i + 1].ActByte) then
        begin
          ActBytesAreEqual := false;
          if (bSwitch [_V]) then
            inc (nBytesFound);
          exit;
        end;
      end;

      if (not bSwitch [_V]) then
        inc (nBytesFound);
    end;

    procedure NextMode;
    begin
      inc (MODUS);
      if (MODUS > 4) then
        MODUS := 1;
      FastPrint (concat (MODI[MODUS], #8));
    end;

    procedure WriteEqualByte (b:byte; nPos:longint);
    begin
      if bSwitch [_NS] then
      begin
        NextMode;
        exit;
      end;

      if bSwitch [_B] then
      begin
        write (chr (b));
      end
      else
      begin
        FastPrint (concat (i2sf (nPos, 5), ' (', hexlong (nPos),')'));
        FastPrint (concat (' ', i2sf (b, 3), ' ', hexbyte (b), ' '));
        if (b < 32) then
          FastPrint ('ù')
        else
          FastPrint (chr (b));

        if not bSwitch [_ND] then
          Disassemble (b);

        FinishLine;
      end;
    end;

    procedure WriteDifferentByte (nPos:longint);
    var i:byte;

        function ToLen (s:string; len:byte):string;
        var strlen, i:byte;
        begin
          strlen := length (s);
          for i:=strlen + 1 to len do
            s := concat (' ', s);
          ToLen := s;
        end;

    begin
      if bSwitch [_NS] then
      begin
        NextMode;
        exit;
      end;

      FastPrint (concat (i2sf (nPos, 5), ' (', hexlong (nPos),')'));
      for i:=1 to nOpenFiles do
        FastPrint (concat (' ³ ', ToLen (i2s (a[i].ActByte), 3), ' ', hexbyte (a[i].ActByte), 'h'));
      FP ('');
    end;

    procedure Write2Pascal (x:byte);
    begin
      inc (nOutCount);
      if (nOutCount <= MAX_OUT) then
      begin
        write (fout, '$', hexbyte (x));
        if (nOutCount < MAX_OUT) then
          write (fout, ', ');

    { check for new line }
        if (nConstCount = 14) then
        begin
          write (fout, #13#10, EINRUECKEN);
          nConstCount := 0;
        end;
      end;
    end;

    function OneEof:boolean;
    var i:byte;
    begin
      OneEof := false;
      for i:=1 to nOpenFiles do
        if (eof (a[i].f)) or (a[i].BytesRead < MAX_BUFFER) then
        begin
          OneEof := true;
          exit;
        end;
    end;

begin
  nConstCount := 0;
  nOffset     := 0;
  nOutCount   := 0;
  nBytesFound := 0;

  repeat
    ReadAllBufs;

    while AllBufOkay do
    begin
      IncBufpos;

{ write to STDOUT }
      nActByte := MAGIC;

      nPos := nOffset + a[1].ActBufPos;

      if (ActBytesAreEqual (nPos)) then
      begin
        if (not bSwitch [_V]) then  { else b = 0 }
        begin
          nActByte := a[1].ActByte;
          WriteEqualByte (nActByte, nPos);
        end;
      end
      else
        if bSwitch [_V] then
          WriteDifferentByte (nPos);

{ check if something should be written to the pascal file }
      if not bSwitch [_NP] then
        Write2Pascal (nActByte);

{ why comparing any more if no output is written }
      if (nOutCount > MAX_OUT) and (bSwitch [_NS]) then
        goto StopCompare;

      if (bSwitch [_S]) and (nBytesFound >= nStop) then
      begin
StopCompare:
        FPX (concat ('Stop comparing after match ', i2s (nStop)));
        exit;
      end;
    end;  { while actpos < minbytesread }

    inc (nOffset, MinBytesRead);
  until (OneEof) or (bSwitch [_AAUTO]);  { if AutoJump - only one buffer }
end;

{$f+}
procedure CloseFiles;
var i:byte;
begin
  if FILES_OPENED > 0 then
  begin
    FPX (concat ('Closing ', i2s (FILES_OPENED), ' file(s)'));

    { close all files }
    for i:=1 to FILES_OPENED do
    begin
      SetFAttr (a[i].f, a[i].OldAttr);
      close (a[i].f);
    end;

    if (PASCAL_OPENED) and (not bSwitch [_NP]) then
    begin
      writeln (fout);  { add a newline }
      if (nOutCount = 0) then
      begin
        erase (fout);
        FPX ('Deleting Pascal file');
      end
      else
      begin
        close (fout);
        FPX ('Closing Pascal file');
      end;
    end;

    FILES_OPENED := 0;

    ExitProc := OldExit;
  end;
end;
{$f-}

var i:byte;
begin
{ enable Ctrl+Break }
  asm
    mov ax, $3300
    mov dl, 1
    int 21h
  end;

  OldExit := ExitProc;
  ExitProc := @CloseFiles;

  for i:=START_METHOD to END_OPTION do
    bSwitch [i] := cmdline.IsFlag (Commands [i].switch);

  EvaluateCommandLine;

  if not bSwitch [_NC] then
    ReadConfigFile;

  if not bSwitch [_NH] then
    PrintCopyright;

{ get all options }

  if bSwitch [_X] then
    ShowOptions;

{ read the files in the Filenames buffer }
  if bSwitch [_F] then
    ScanDisk
  else
    ReadCommandline;

  bOnlyOneFile := (nOpenFiles = 1);
  if bOnlyOneFile then
    FPX ('Found only one file to capture startup code.');

  if (nOpenFiles < 1) or
     (bSwitch [_H]) or
     (cmdline.IsFlag ('?')) then
    Syntax;

  bPE := false;

  AssignHandles;
  CheckEXEHeader;
  SearchStartPos;

  if not bSwitch [_NP] then
    OpenPascalFile;

  InitGraphics;

  CompareFiles;

  FPX ('all done');
  CloseFiles;
end.
